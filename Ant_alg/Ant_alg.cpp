/* Файл Ant_alg.cpp */
/* ОТИ МИФИ */
/* 1ПО-24Д */
/* Баинбетова Владлена Владиславна */
/* Алгоритмы и структура данных */
/* Программа Ant_alg */
/* Вспомогательный модуль */
/* 19.05.2016 */

/* Подключение библиотек */
#include "Ant_alg.h"
#include <locale>
#include <stdlib.h>
#include <iostream>
#include <malloc.h>
#include <conio.h>
#include <time.h>

/* Подключение пространства имен */
using namespace std;

/* Функция ReadSize	                                                            */
/* Назначение:                                                                  */
/*      Чтение графа из файла и запись его размера                              */
/* Входные данные:                                                              */
/*      D	 - ссылка на массив, содержащий длины всех дуг в графе              */
/*      name - название файла, содержащий граф                                  */
/*      n    - переменная, содержащая количество вершин в графе                 */
/* Выходные данные:                                                             */
/*      D	 - ссылка на массив, содержащий длины всех дуг в графе              */
/*      name - название файла, содержащий граф                                  */
/*      n	 - переменная, содержащая количество вершин в графе                 */
/* Возвращаемое значение:                                                       */
/*      size - размер матрицы смежности                                         */
int ReadSize(double **D, char name[SIZE], int *n)
{
	/* Объявление перменных */
	FILE *input = NULL;
	int size = 0, j = 0;
	char ch = 0;

	/* Окрытие файла на чтение */
	if (fopen_s(&input, name, "rb") == NULL)
	{
		/* Чтение из файла до конца */
		while (!feof(input))
		{
			ch = fgetc(input);
			/* Перенос строки */
			if (ch == '\n') { 
				size++;  
				j = 0; 
			}
			/* Другие символы */
			else if (ch == '\xff' || ch == '\r') {} 
			/* Пробел */
			else if (ch == ' ') { 
				j++; 
			}
			else if (ch == '-') { 
				printf("Граф содержит отрицательный вес ребра.\nНевозможно применение муравьиного алгоритма.\nДля продолжения нажмите любую клавишу...\n"); 
				/* Задержка сообщения на экране */
				_getch();
				exit(0); 
			}
		}
		/* Закрытие файла */
		fclose(input);
		/* Запись размера матрицы */
		*n = size;
	} else {
		/* Уведомление об ошибке*/
		cout << "Ошибка: невозможно открыть файл.\nДля продолжения нажмите любую клавишу...\n";
		/* Задержка сообщения на экране */
		_getch();
		/* Выход из программы */
		exit(0);
	}
	/* Возврат размера матрицы */
	return size;
}

/* Функция ReadMatrix                                                           */
/* Назначение:                                                                  */
/*      Чтение графа из файла и запись его в массив                             */
/* Входные данные:                                                              */
/*      D	 - ссылка на массив, содержащий длины всех дуг в графе              */
/*      name - название файла, содержащий граф                                  */
/*      n    - переменная, содержащая количество вершин в графе                 */
/* Выходные данные:                                                             */
/*      D	 - ссылка на массив, содержащий длины всех дуг в графе              */
/*      name - название файла, содержащий граф                                  */
/*      n    - переменная, содержащая количество вершин в графе                 */
/* Возвращаемое значение:                                                       */
/*      size - размер матрицы смежности                                         */
int ReadMatrix(double **D, char name[SIZE], int *n) {
	/* Объявление перменной */
	FILE *input = NULL;

	/* Вызов функции readSize */
	int size = ReadSize(D, name, n);

	/* Окрытие файла на чтение */
	if (fopen_s(&input, name, "rb") == NULL)
	{
		for (int t = 0; t < size; ++t) {
			for (int k = 0; k < size; ++k) {
				int num;
				fscanf_s(input, "%d", &num);
				D[t][k] = num;
				/* Обрабатываем тот случай, если не существует маршрута из t в k (если только это не петля) */
				if (t != k && D[t][k] == 0) D[t][k] = INFINITY; // теперь здесь находиться бесконечность
			}
		}
		/* Закрытие файла */
		fclose(input);
	}
	return size;
}

/* Функция Probability					                                          */
/* Назначение:                                                                    */
/*      Подсчет вероятности перехода муравья в город	                          */
/* Входные данные:																  */
/*      to		- город, куда хочет перейти муравей								  */
/*      ant		- муравей														  */
/*      tao		- ссылка на массив с феромоном									  */
/*      epsilon - ссылка на массив с видимостью									  */
/*		size	- размер матрицы смежности										  */
/* Выходные данные:                                                               */
/*      to		- город, куда хочет перейти муравей								  */
/*      ant		- муравей														  */
/*      tao		- ссылка на массив с феромоном									  */
/*      epsilon - ссылка на массив с видимостью									  */
/*		size	- размер матрицы смежности										  */
/* Возвращаемое значение:                                                         */
/*      res		- значение вероятности перехода                                   */
double Probability(int to, ANT_TYPE ant, double **tao, double **epsilon, int size) {
	double res = 0.0, sum = 0.0;
	int from = ant.array[ant.number - 1];
	/* Если вершина уже посещена, возвращаем 0 */
	for (int i = 0; i < ant.number; ++i) {
		if (to == ant.array[i]) {
			return 0.0;
		}
	}
	/* Подсчет суммы в знаминателе */
	for (int j = 0; j < size; ++j) {
		int flag = 1;
		/* Проверка: посещал ли муравей j вершину? */
		for (int i = 0; i < ant.number; ++i) {
			if (j == ant.array[i]) {
				flag = 0;
			}
		}
		/* Если нет, тогда прибавляем к общей сумме */
		if (flag && from >= 0) {
			sum += pow(tao[from][j], ALPHA) * pow(epsilon[from][j], BETA);
		}
	}
	if (from >= 0) {
		/* Возврат значения вероятности */
		res = pow(tao[from][to], ALPHA) * pow(epsilon[from][to], BETA) / sum;
	}
	return res;
}

/* Функция InitializationLength                                                   */
/* Назначение:                                                                    */
/*      Начальная нициализация длины пути				                          */
/* Входные данные:																  */
/*      epsilon - ссылка на массив с видимостью									  */
/*		D		- ссылка на массив, содержащий длины всех дуг в графе			  */
/*		size	- размер матрицы смежности										  */
/* Выходные данные:                                                               */
/*      epsilon - ссылка на массив с видимостью									  */
/*		D		- ссылка на массив, содержащий длины всех дуг в графе			  */
/*		size	- размер матрицы смежности										  */
/* Возвращаемое значение:                                                         */
/*      отсутствует                                                               */
void InitializationLength(double **epsilon, double **D, int size) {
	for (int i = 0; i < size; ++i) {
		/* Создание двумерного динамического массива */
		epsilon[i] = (double *)malloc(sizeof(double) * size);
		for (int j = 0; j < size; ++j) {
			/* Если текущее ребро не является петлей */
			if (i != j) { 
				epsilon[i][j] = 1.0 / D[i][j];
			}
		}
	}
}

/* Функция GenerationPheromon                                                     */
/* Назначение:                                                                    */
/*      Начальная генерация феромона					                          */
/* Входные данные:																  */
/*		tao	 - ссылка на массив с начальным феромоном							  */
/*		size - размер матрицы смежности											  */
/* Выходные данные:                                                               */
/*		tao	 - ссылка на массив с начальным феромоном							  */
/*		size - размер матрицы смежности											  */
/* Возвращаемое значение:                                                         */
/*      отсутствует                                                               */
void GenerationPheromon(double **tao, int size) {
	/* Генерация феромона */
	srand((unsigned)time(NULL));
	for (int i = 0; i < size; ++i) {
		/* Создание двумерного динамического массива */
		tao[i] = (double *)malloc(sizeof(double) * size);
		for (int j = 0; j < size; ++j) {
			/* Случайное заполнение массива, значения которых от 1 до size */
			tao[i][j] = 1 + (size * rand() / RAND_MAX);
		}
	}
}

/* Функция InitializationLength                                                   */
/* Назначение:                                                                    */
/*      Начальное размещение муравьев					                          */
/* Входные данные:																  */
/*      ants	- массив с колонией муравьев  									  */
/*		size	- размер матрицы смежности										  */
/*		city_1	- начальный город												  */
/* Выходные данные:                                                               */
/*      ants	- массив с колонией муравьев  									  */
/*		size	- размер матрицы смежности										  */
/*		city_1	- начальный город												  */
/* Возвращаемое значение:                                                         */
/*      отсутствует                                                               */
void InitializationAnts(ANT_TYPE ants[M], int size, int city_1) {
	/* Цикл по всем муравьям */
	for (int k = 0; k < M; ++k) {
		ants[k].number = 0;
		ants[k].length = 0.0;
		ants[k].array = (int *)malloc(sizeof(int) * size);
		/* Размещение колонии в начальной вершине */
		ants[k].array[ants[k].number++] = city_1;
	}
}

/* Функция Pheromon			                                                      */
/* Назначение:                                                                    */
/*      Обновление феромона			 					                          */
/* Входные данные:																  */
/*      ants	- массив с колонией муравьев  									  */
/*      Q		- начальный параметр алгоритма									  */
/*		size	- размер матрицы смежности										  */
/*      tao		- ссылка на массив с феромоном									  */
/*      k		- номер муравья в колонии										  */
/* Выходные данные:                                                               */
/*      ants	- массив с колонией муравьев  									  */
/*      Q - начальный параметр алгоритма										  */
/*		size	- размер матрицы смежности										  */
/*      tao		- ссылка на массив с феромоном									  */
/*      k		- номер муравья в колонии										  */
/* Возвращаемое значение:                                                         */
/*      отсутствует                                                               */
void Pheromon(ANT_TYPE ants[M], double Q, double **tao, int k) {
	for (int i = 0; i < ants[k].number - 1; ++i) {
		/* Объявление и инициализация переменных */
		int from = ants[k].array[i % ants[k].number];
		int to = ants[k].array[(i + 1) % ants[k].number];
		tao[from][to] += Q / ants[k].length;
		tao[to][from] = tao[from][to];
	}
}

/* Функция AntColony                                                              */
/* Назначение:                                                                    */
/*      Нахождение пути с помощью муравьиного алгоритма                           */
/* Входные данные:                                                                */
/*      D	   - ссылка на массив, содержащий длины всех дуг в графе              */
/*		size   - размер матрицы смежности										  */
/*		city_1 - начальный город												  */
/*		city_2 - конечный город													  */
/* Выходные данные:                                                               */
/*      D	   - ссылка на массив, содержащий длины всех дуг в графе              */
/*		size   - размер матрицы смежности										  */
/*		city_1 - начальный город												  */
/*		city_2 - конечный город													  */
/* Возвращаемое значение:                                                         */
/*      way	- кратчайший маршрут, количетсво его вершин и длина                   */
ANT_TYPE AntColony(double **D, int size, int city_1, int city_2) {
	/* Начальная инициализация данных о лучшем маршруте */
	ANT_TYPE way;
	way.number = 0;
	way.length = -1;
	way.array = (int *)malloc(sizeof(int) * size);
	double Q = 1.0;
	ANT_TYPE ants[M];
	/* Инициализация данных о расстоянии и количестве феромона */
	double **epsilon = NULL, **tao = NULL;
	/* Создание динамических массивов */
	epsilon = (double **)malloc(sizeof(double *) * size);
	tao = (double **)malloc(sizeof(double *) * size);

	/* Вызов функции для инициализации начального пути */
	InitializationLength(epsilon, D, size);

	/* Вызов функции для генерации феромона */
	GenerationPheromon(tao, size);
	
	/* Вызов функции для размещения всех муравьем в начальном городе */
	InitializationAnts(ants, size, city_1);
	
	/* Основной цикл муравьиного алгоритма */
	for (int t = 0; t < T_MAX; ++t) {
		/* Цикл по муравьям */
		for (int k = 0; k < M; ++k) {
			/* Локальный поиск маршрута для k-го муравья */
			do {
				int J_max = -1;
				double P_max = 0.0;
				for (int j = 0; j < size; ++j) {
					/* Проверка вероятности перехода в вершину j */
					if (ants[k].array[ants[k].number - 1] != j) {
						/* Вызов функции для подсчета вероятности */
						double P = Probability(j, ants[k], tao, epsilon, size);
						if (P != 0 && P >= P_max) {
							P_max = P; // запоминаем большую вероятность
							J_max = j; // запоминаем номер города, которому соответствует эта вероятность
						}
					}
				}
				if (J_max >= 0) {
					/* Подсчёт пройденного пути и составление маршрута */
					ants[k].length += D[ants[k].array[ants[k].number - 1]][J_max]; // текущей длине приравнивается значение из D
					ants[k].array[ants[k].number++] = J_max;
				}
			} while (ants[k].array[ants[k].number - 1] != city_2); // пока не достигнута конечная вершина
			
			/* Оставляем след феромона от колоний */
			Pheromon(ants, Q, tao, k);
			
			/* Проверка: нашли лучшее решение? */
			if (ants[k].length < way.length || way.length < 0) { // т.е. длина построенного маршрута меньше той, которая дана изнчально задана в графе
				/* Переприсваивание номеров вершин, длин и маршрута */
				way.number = ants[k].number;
				way.length = ants[k].length;
				for (int i = 0; i < way.number; ++i) {
					way.array[i] = ants[k].array[i];
				}
			}
			/* Обновление муравьев */
			ants[k].number = 1;
			ants[k].length = 0.0;
		}
		/* Цикл по ребрам */
		for (int i = 0; i < size; ++i) {
			for (int j = 0; j < size; ++j) {
				/* Обновление феромона для ребра (i, j) с учетом его испарения */
				if (i != j) {
					tao[i][j] *= (1 - p);
				}
			}
		}
	}

	/* Освобождение памяти */
	free(epsilon);
	free(tao);
	
	/* Возврат кратчайшего маршрута */
	return way;
}

/* Функция PrintResult                                                            */
/* Назначение:                                                                    */
/*      Вывод кратчайшего маршрута и его длины на экран							  */
/* Входные данные:																  */
/*      way	- кратчайший маршрут, количетсво его вершин и длина                   */
/* Выходные данные:                                                               */
/*      way	- кратчайший маршрут, количетсво его вершин и длина                   */
/* Возвращаемое значение:                                                         */
/*      отсутствует                                                               */
void PrintResult(ANT_TYPE way) {
	system("cls");
	cout << "Путь: " << ++way.array[0];
	for (int i = 1; i < way.number; ++i) {
		cout << " -> " << ++way.array[i];
	}
	cout << "\nДлинна пути: " << way.length << endl;
	cout << "Для продолжения нажмите любую клавишу..." << endl;
}